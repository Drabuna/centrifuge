<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <style type="text/css">
            input[type="text"] { width: 300px; }
            .muted {color: #CCCCCC; font-size: 10px;}
        </style>
        <script type="text/javascript" src="http://localhost:2000/centrifuge.js"></script>
        <script type="text/javascript">
            // helper functions to work with escaping html.
            const tagsToReplace = {'&': '&amp;', '<': '&lt;', '>': '&gt;'};
            function replaceTag(tag) {return tagsToReplace[tag] || tag;}
            function safeTagsReplace(str) {return str.replace(/[&<>]/g, replaceTag);}

            const channel = "chat:index";

            let centrifuge;

            window.addEventListener('load', function() {
                const input = document.getElementById("input");
                const container = document.getElementById('messages');

                centrifuge = new Centrifuge('ws://' + window.location.host + '/connection/websocket', {
                    protocolVersion: 'v2',
                    debug: true,
                });

                centrifuge.on('state', function (ctx) {
                    drawText(ctx.prevState + ' -> ' + ctx.state);
                });

                centrifuge.on('connect', function(ctx){
                    drawText('Connected with client ID ' + ctx.client + ' over ' + ctx.transport);
                    input.removeAttribute("disabled");
                });

                centrifuge.on('error', function(ctx) {
                    console.log(ctx);
                });

                centrifuge.on('publication', handlePublication);

                centrifuge.on('subscribe', function (ctx) {
                    drawText('Subscribed on channel ' + ctx.channel);
                });

                centrifuge.on('unsubscribe', function (ctx) {
                    drawText('Unsubscribed from channel ' + ctx.channel);
                });

                // Disconnect may be called:
                // * Clean disconnect of a client, both server-side and client-side subscriptions are kept.
                // * Clean close of client, both server-side and client-side subscriptions closed and removed.
                // * Disconnect code without reconnect from server, both server-side and client-side subscriptions closed and removed.
                // * Disconnect code with reconnect advice from server, both server-side and client-side subscriptions are kept.
                // * Fatal non-retryable error, both server-side and client-side subscriptions closed and removed.
                // * Unrecoverable position for server-side subscriptions. Client-side subscription information is still kept.
                centrifuge.on('disconnect', function(ctx){
                    drawText('Disconnected: ' + ctx.reason + (ctx.reconnect?", will try to reconnect":", won't try to reconnect"));
                    input.setAttribute('disabled', 'true');
                });

                // Connection to the server closed. Client won't keep reconnecting.
                // Reasons:
                // * Clean close of client, both server-side and client-side subscriptions closed and removed.
                // * Disconnect code without reconnect from server, both server-side and client-side subscriptions closed and removed.
                // * Fatal non-retryable error, both server-side and client-side subscriptions closed and removed.
                // * Unrecoverable position for server-side subscriptions. Client-side subscription information is still kept.
                centrifuge.on('close', function (ctx) {
                    drawText('Closed: '+ ctx.reason);
                    // centrifuge.connect();
                });

                // create new subscription on a channel and bind various event listeners.
                const sub = centrifuge.newSubscription(channel)
                        .on('state', handleState)
                        .on('publication', handlePublication)
                        .on("join", handleJoin)
                        .on("leave", handleLeave)
                        .on("subscribe", handleSubscribe)
                        .on("error", handleSubscribeError)
                        .on("unsubscribe", handleUnsubscribe)
                        .on('close', handleClose);

                // Start subscribing, request will be queued until client connects to a server.
                sub.subscribe();

                // function resubscribe() {
                //     setTimeout(function () {
                //         sub.unsubscribe();
                //         setTimeout(function () {
                //             sub.subscribe();
                //             resubscribe();
                //         }, 2000)
                //     }, 1000);
                // }
                // resubscribe();
                //
                // function reconnect() {
                //     setTimeout(function () {
                //         centrifuge.disconnect();
                //         setTimeout(function () {
                //             centrifuge.connect();
                //             reconnect();
                //         }, 2000)
                //     }, 1000);
                // }
                // reconnect();

                // Trigger actual connection establishing with a server.
                // At this moment actual client work starts - i.e. subscriptions
                // defined start subscribing etc.
                centrifuge.connect();

                function handleState(ctx) {
                    drawText('Subscription state: ' + ctx.prevState + ' -> ' + ctx.state);
                }

                function handleClose(ctx) {
                    drawText('Subscription closed for channel ' + ctx.channel + ', reason: ' + ctx.reason);
                    sub.subscribe();
                }

                function handleSubscribe(ctx) {
                    drawText('Subscribed on channel ' + ctx.channel);
                    showPresence(sub);
                }

                function handleSubscribeError(err) {
                    drawText('Error subscribing on channel ' + err.channel + ': ' + err.message);
                }

                function handlePublication(message) {
                    let clientID;
                    if (message.info){
                        clientID = message.info.client;
                    } else {
                        clientID = null;
                    }
                    const inputText = 'Offset ' + message.offset.toString() + ': ' + message.data["input"].toString();
                    const text = safeTagsReplace(inputText) + ' <span class="muted">from ' + clientID + '</span>';
                    drawText(text);
                }

                function handleJoin(message) {
                    drawText('Client joined channel ' + this.channel + ' (uid ' + message.info["client"] + ', user '+ message.info["user"] +')');
                }

                function handleLeave(message) {
                    drawText('Client left channel ' + this.channel + ' (uid ' + message.info["client"] + ', user '+ message.info["user"] +')');
                }

                // Unsubscribe can be caused by:
                // Client disconnect, we keep subscription state.
                // Client close, we remove subscription state.
                // Client unrecoverable position, subscription state kept.
                // Unsubscribe from a server
                // Subscription unrecoverable position, internal state removed.
                function handleUnsubscribe(ctx) {
                    drawText('Unsubscribed from channel ' + ctx.channel);
                }

                function showPresence(sub) {
                    sub.presence().then(function(result) {
                        let count = 0;
                        for (let key in result.presence){
                            count++;
                        }
                        drawText('Presence: now in this room – ' + count + ' clients');
                    }, function(err) {
                        drawText("Presence error: " + JSON.stringify(err));
                    });
                }

                function drawText(text) {
                    let e = document.createElement('li');
                    e.innerHTML = [(new Date()).toString(), ' ' + text].join(':');
                    container.insertBefore(e, container.firstChild);
                }

                document.getElementById('form').addEventListener('submit', function(event) {
                    event.preventDefault();
                    sub.publish({"input": input.value}).then(function() {
                        // message accepted by server.
                    }, function(err) {
                        console.log('error publishing message', err);
                    });
                    input.value = '';
                });
            });
        </script>
    </head>
    <body>
        <form id="form">
            <input type="text" id="input" autocomplete="off" />
            <input type="submit" id="submit" value="»">
        </form>
        <ul id="messages"></ul>
    </body>
</html>
